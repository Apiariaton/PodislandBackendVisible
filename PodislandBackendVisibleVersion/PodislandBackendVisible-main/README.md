Plan:

I am going to create a full-stack application, which uses React, Node.js, Firebase, Stripe,
and eventually sockets.io, as well as Python AI to drive a recommendation engine within the
web application.

The framework with which I will construct this application will be as follows. Number 1: create
the React webpages for this application. This application will have three variant designs:
one for desktop computer, one for iPad and one for iPhone. This application will also have a 
dark and light mode which will be managed via React useContext. The application will manage
state via redux toolkit. The state it will manage will relate to the following data. The
username and the user authentication token; the user age; the user rank; the user avatar 
image; the user messages; the user description. 

The other data which will be managed via React redux will be the podcasts which will
be featured on the website. These will include a link to the podcast, the podcast title, an image
to represent the podcast and a podcast description, as well as a like button.

The data relating to likes and dislikes will be stored within a separate Firebase database, which
will later be converted to CSV for machine learning and data analysis by a machine learning 
program.

There will therefore be a few databases in operation for the program: the user-specific information
will be stored within a MongoDB database. The only podcast data it will include are the podcasts
which the user likes.

There will be a second Firebase database and a third Firebase database. The second Firebase
database will include data relating to the podcasts itself. The third Firebase database will be a
database which records a matrix of user’s likes and dislikes - in other words, it will record whether
a user likes a given podcast.

There will be an API whereby a user can do the following: they can create a user profile; they can
reset their password; they can upload a user avatar from a given number of options; they can
delete their account; they can login. An email will be sent when a user has created an account,
when they delete an account and when they make a ‘purchase’.

Each will represent a separate end point.

A series of test cases will be written to ensure that each meets the necessary criteria: email
should be valid; username should be valid; email should be unique; password should be unique;
non-images should be rejected; unwanted files should also be identified.

This back-end api should be written in Node.js and use MongoDB and Mongoose. It should use
the following NPM libraries: express, validator, bcrypt.js, express-rate-limiting, multer, mongoose, XSS Cross-Scripting, 
CLAM AV, Stripe.js, jest.

All API variables should be stored within an environment variables file which is not added to Github.

The variables should be added as configurable environment variables within the given production
environment.

A security class should be written using Javascript Classes, which is configurable according 
to the needs of the given API Express route.

The Stripe payment method should be handled in Node; stripe should be used in testmode
and the user should not be able to change this.

The Home Page should permit the user to filter podcasts by descriptor. These descriptors
can be stored as an array to the Mongoose model. Other filters should include genre, publication
date, number of downloads, date of release.

There should be a Node API endpoint whereby one can filter data from the Firebase model which relates to podcast genre,
publication, number of downloads etc. This endpoint should be queried when you interact
with the filter page on the web application podcast home page. Each filter should be non-exclusive.
This means that it should be possible to stack filters on top of one another.

This should be possible via Firebase’s orderby property: https://firebase.google.com/docs/database/rest/retrieve-data#:~:text=timeout%3D10s'-,Filtering%20Data,startAt%20%2C%20endAt%20%2C%20and%20equalTo%20.

It should be possible to paginate through the application depending on the number of results.

This should be done by writing a function which obtains the number of results. If the number
of results exceeds the threshold for the page, then the number of results is divided by the 
results per page count. Links are conditionally rendered in React, such that by clicking the next
icon or the number, new content is produced, as the state is updated to reflect the page number.
Each page number is linked to the content, as a dictionary key to the content’s entry. This is updated
whenever the page is refreshed.

The value of the search and search buttons will be sanitized, then sent to the API via a time-limited
useEffect call. There will be a series of title tags, which will be generated by ChatGPT to describe
search terms that may resemble the query entered by the user. This will allow for broader matches.
. The search function buttons will resemble the Headspace login buttons.

Authentication will only be required to manage the user account; Firebase Google Authentication
could be added to the user profile options, so that the user can sign in via a Google Account.

A basket will be configured via Redux Toolkit; it will be a collection which is stored on Mongo
and be dependent on the user logging in.

The authentication token which is received upon login will be stored to the localstorage.
The authentication token will expire after 14 days.

Initially, I will only create the following pages: Shop, Podcasts, User Account:
I will then create the Forum after following the websocket tutorial and eventually the AI and ML
learning recommendation feature, once I have followed the tutorial for these.

How to integrate Google Authentication within sign-in? You can do the following: 
-Add Firebase Authentication to project
-Import FirebaseAuth
-Use the Sign-In with Google  method to return a token (Use Sign-In with Google)
-Initialise a credential with this token
-Sign in using this credential
-Add a field to MongoDB which describes whether an account is a Google account and 
-Disable reset password if Google Account
-Allow the normal order operations for the account

https://firebase.google.com/docs/auth/web/google-signin#advanced-handle-the-sign-in-flow-manually



Action Plan:
Create the design for mobile, iPad and desktop
Obtain the podcast data, including links to the podcast data. ✔
Create the API using Node, Mongo and Firebase.
Test the API.
Create the front-end in React.
Test the front-end in React.
Combine the front-end and back-end.
Test and upload to Netlify or similar.


Follow SOLID principles throughout the process.

https://itunes.apple.com/search?term=science&ratingIndex=80&country=gb&media=podcast&limit=20&output=json&genreIndex=Science&genreIndex!=Science+Fiction

JSON data

Node API plan and structure as well as the test suite to ensure everything goes to plan:
-Set up the config folder to store my secret, port and other environment variables
-Create a folder which stores PodcastFunctions
 PodcastFunctionsTestSuite + podcastFns.test.js
-Create a folder which stores UserFunctions
-Each folder should containing a folder UserFunctionsTestSuite userFns.test.js
-Create a file called podIsland.test.js
-Create an index.js file
-Create a folder to store Mongoose model for User and orders
-Create a folder to store database initialisation function
-Install the relevant libraries
-Create a folder for the security class / object
-Create a folder for each router, with the following categories:

-Login, Logout, LogoutAll, Create User, Delete User [ Router 1 ]
-Toggle Like [ Router 2 ] 
-Create New Order, Cancel Order which was made two days previously or sooner [ Router 3]
-Upload Profile Image [ Router 4 ]
-Get User Data, Forgot Password [ Router 5 ] GDPR purposes
-Filter Podcast Data / Filter Shop Data [Router 6]

-Create validation functions which prevent cross-scripting and other malware attacks
-Create User model with validation function
-Create Orders model with validation function
-Create authentication function, which requires a user to have logged in to permit the operation
-Install express rate limiting library

-Write the paths for Router 1
-Write a series of test cases for Router 1
-Can you login with invalid credentials?
-Can you logout  when you are not logged in?
-Are all tokens successfully removed when you logout all?
-Can you create a username with the same credentials as someone else?
-Can you view another person’s details though not logged in as them?
-Can you delete your account successfully?

Write the paths for Router 2
-When you toggle Like is this reflected on the Like Buttons?
-Is the likeData stored locally?
-Is data sent to the correct user ok?

Write the paths for Router 3
-Can you create a new order when not logged in?
-Can you create an order for someone else?
-Can you make an empty order or an order with negative numbers?
-Does new order successfully trigger a Stripe dialogue window?

Write the paths for Router 4
-Can you upload a non-image?
-Can you upload an image which is bigger than 2MB?
-Can you upload an image if you are not logged in?

Write the paths for Router 5
-When you call getUserData, what data do you get?
-Does this return data only for the user in question?

Write the paths for Router 6
-Can the user retrieve more than 50 results at a time?
-Can you query podcasts by three attributes?
-Can you query products by three attributes?
-Can you use the skip button to only see those entries which are relevant to you?
-Are the number of results returned to React, so that React can conditionally render skip buttons?

-Can you access the MongoDB database credentials without a password and username?
